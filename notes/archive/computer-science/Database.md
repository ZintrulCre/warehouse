---
title: "数据库"
date: 2015-07-05T08:57:52+10:00
draft: true
categories: ["Computer Science"]
---

# 数据库

## 数据库设计

### 关系数据理论

- 数据依赖是指内部属性之间的约束关系

### 范式 Normal Form

- 范式是数据库的表结构的设计标准，有 1NF, 2NF, 3NF, BCNF, 4NF, 5NF 等

1. 第一范式
    - 1NF 是指数据库表的每个属性都不可再分
    - 1NF 是所有关系型数据库的最基本要求
    - 坏处：数据冗余，插入异常，修改异常，删除异常

2. 第二范式
    - 2NF 是指在 1NF 的基础之上，消除了非主属性对于主键的部分函数依赖
    - 非主属性完全依赖于主键

3. 第三范式
    - 3NF 是指在 2NF 的基础之上，消除了非主属性对于主键的传递函数依赖
    - 非主属性不依赖于其它非主属性

## MySQL 存储引擎

### InnoDB

- MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎
- 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）；在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读
- 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升
- 内部进行了优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等
- 支持在线热备份；其它存储引擎在需要获取一致性视图时会停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取
- 特性：插入缓冲（insert buffer），二次写（double write），自适应哈希索引（ahi），预读（read ahead）

### MyISAM

- 设计简单，数据以紧密格式存储；对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它
- 提供了大量的特性，包括压缩表、空间数据索引等
- 不支持事务
- 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）
- 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的
- 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作

### 对比

- 事务：InnoDB 支持事务，可以使用 Commit 和 Rollback 语句；而 MyISAM 不支持
- 并发：InnoDB 支持行级锁；而 MyISAM 只支持表级锁
- 控制：InnoDB 支持 MVCC；而 MyISAM 不支持
- 外键：InnoDB 支持外键；而 MyISAM 不支持
- 索引：MyISAM 支持全文索引；而 InnoDB 不支持
- 备份：InnoDB 支持在线热备份
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢
- 其它：MyISAM 支持压缩表和空间数据索引

## 事务 Transaction

- 事务是一个操作序列，用来维护数据的一致性
- 满足 ACID 原则

### ACID 原则

1. 原子性 Atomic：事务被视为不可分割的最小单元，其所有操作要么全部提交成功，要么全部失败回滚；回滚可以用回滚日志来实现，回滚日志记录事务所执行的修改操作，在回滚时反向执行所有的修改操作
2. 一致性 Consistency：数据库在事务执行前后都保持一致性状态；在一性状态下，所有事务对一个数据的读取结果都是相同的
3. 隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务不可见的
4. 持久性 Durability：一旦事务提交，则其所做的修改将会永远保存到数库中；使用重做日志来保证持久性

- 只有满足一致性，事务的执行结果才是正确的
- 在无并发的情况下，事务串行执行，隔离性一定能够被满足；此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性；
- 事务满足持久化是为了能应对数据库崩溃的情况
- MySQL 默认采用自动提交模式 AUTOCOMMIT；如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务被自动提交

## 并发

### 并发一致性问题

- 产生并发一致性问题主要原因是破坏了事务的隔离性
- 解决方法是通过并发控制来保证隔离性

1. 丢失修改
    - T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改

2. 读脏数据
T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据

3. 不可重复读
T2 读取一个数据，T1 对该数据做了修改；如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同

4. 幻影读
T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同

### 并发控制

- 并发控制包括封锁（需要用户自己控制，复杂）和事务的隔离级别（数据库系统自带，简单）

#### 封锁

##### 封锁粒度

- MySQL 中提供了两种封锁粒度：行级锁和表级锁

- 应该尽量只锁定需要修改的部分数据，而不是所有的资源；锁定的数据量越少，发生锁争用的可能性越小，系统的并发程度越高
- 加锁需要消耗资源，锁的各种操作（包括获取、释放、以及检查状态）都会增加系统开销；因此封锁粒度越小，系统开销就越大。
- 在选择封锁粒度时，需要在锁开销和并发程度之间做权衡

##### 封锁类型

1. 读写锁
    - 排它锁（Exclusive），简写为 X 锁，又称写锁
    - 共享锁（Shared），简写为 S 锁，又称读锁
    - 如果一个事务对数据对象 A 加了排它锁，那么它可以对 A 进行读取和更新，而其它事务不能对 A 加任何锁
    - 如果一个事务对数据对象 A 加了共享锁，那么它可以对 A 进行读取操作，但是不能进行更新操作，其它事务能对 A 加共享锁，但是不能加排它锁
    - 在存在行级锁和表级锁的情况下，如果事务 T 想要对表加排它锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，非常耗时

2. 意向锁
    - 意向锁（Intention Locks）可以更容易地支持多粒度封锁
    - 意向锁在 X/S 锁之上引入了 IX/IS，IX/IS 都是表级锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁
        - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或更强的锁
        - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁
    - 通过引入意向锁，如果事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败

#### 隔离级别

- 未提交读（READ UNCOMMITTED）
    - 事务中的修改，即使没有提交也对其它事务可见

- 提交读（READ COMMITTED）
    - 事务中的修改，只能在被提交之后才对其它事务可见

- 可重复读（REPEATABLE READ）
    - 保证在同一个事务中多次读取同样数据的结果是一样的

- 可串行化（SERIALIZABLE）
    - 强制事务串行执行
    - 需要加锁实现，而其它隔离级别通常不需要。

##### 多版本并发控制

- 多版本并发控制（MVCC, Multi-Version Concurrency Control）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种方式，用于实现提交读和可重复读这两种隔离级别；未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，无法使用 MVCC 实现

- 版本号
    - 系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会递增
    - 事务版本号：事务开始时的系统版本号

- MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号
    - 创建版本号：表示创建一个数据行的快照时的系统版本号
    - 删除版本号：如果删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了

- Undo 日志
    - MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来

##### Next-Key Locks

- Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现
- MVCC 不能解决幻影读问题；在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题
- Record Locks
    - 锁定一个记录上的索引，而不是记录本身
    - 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用
- Gap Locks
    - 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15
    - `SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;`
- Next-Key Locks
    - Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：
    ```
    (-∞, 10]
    (10, 11]
    (11, 13]
    (13, 20]
    (20, +∞)
    ```

## 锁

### 粒度

#### 1. 表锁

- 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
- 表锁分为表读锁 Table Read Lock 和表写锁 Table Write Lock
    - 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
    - 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁
    - 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁

#### 2. 行锁

- 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高
- 共享锁 S：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁；也叫做读锁：读锁是共享的，多个客户可以同时读取同一个资源，但不允许其他客户修改。
- 排他锁 X：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁；也叫做写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。

- MyISAM 只支持表锁，而 InnoDB 两者都支持

#### 1. 悲观锁

- 悲观并发控制，又名悲观锁 Pessimistic Concurrency Control
- 悲观并发控制可以阻止一个事务以影响其他用户的方式来修改数据
- 如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作
- 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中

#### 2. 乐观锁

- 乐观并发控制， 又名乐观锁，Optimistic Concurrency Control
- 乐观并发控制假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的部分数据
- 在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据；如果是，那么正在提交的事务将会进行回滚

## 切分 Sharding

- Sharding 是把数据库扩展到多个物理节点上，切分后每个节点包含数据库的一个shard；一般由水平分区和垂直分区
- 目的是为了突破单个节点的 I/O，以提升效率和扩展性

### 切分方式

#### 1. 横向扩展 Scale Out

- 添加更多的机器，

#### 2. 纵向扩展 Scale Up

- 添加更多的计算资源（CPU，存储设备，内存）

### 切分策略

#### 1. 垂直切分

- 将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用经常被使用的列和不经常被使用的列切分
- 场景
    1. 大字段的垂直切分；单独将大字段建在另外的表中，提高基础表的访问性能，原则上在性能关键的应用中应当避免数据库的大字段
    2. 按照使用用途垂直切分。例如企业物料属性，可以按照基本属性、销售属性、采购属性、生产制造属性、财务会计属性等用途垂直切分
    3. 按照访问频率垂直切分。例如电子商务、Web 2.0系统中，如果用户属性设置非常多，可以将基本、使用频繁的属性和不常用的属性垂直切分开

#### 2. 水平分片

- 将同一个表中的记录拆分到多个结构相同的表中
- 当一个表的数据不断增多时，Sharding 是必须的，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力
- 场景
    1. 在线电子商务网站，订单表数据量过大，按照年度、月度水平切分
    2. Web 2.0 网站注册用户、在线活跃用户过多，按照用户ID范围等方式，将相关用户以及该用户紧密关联的表做水平切分
    3.  例如论坛的置顶帖子，因为涉及到分页问题，每页都需要显示置顶贴，这种情况可以把置顶贴水平切分开来，避免取置顶帖子时从所有帖子的表中读取

### 切分问题

1. 事务问题
    - 使用分布式事务来解决，比如 XA 接口
2. 连接
    - 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接
3. ID 唯一性
    - 使用全局唯一 ID（GUID）
    - 为每个分片指定一个 ID 范围
    - 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)

## 主从复制

### 读写分离

- 读写分离是指只在主服务器上写，在从服务器上读
- 让主数据库处理事务性查询，而从服务器处理 select 查询
- 数据库复制被用来把事务性查询导致的变更同步到从数据库中

## NoSQL

### MongoDB

|MySQL|MongoDB|
|---|---|
|表|集合 Collection|
|行|文档 Document|
|列|字段|

- 文档由一组 key-value对 组成
- 同一集合里的文档不需要有相同的字段和结构；而在关系型数据库表每一条记录需要有相同的结构

#### 持久化

- MongoDB 专门维护一个线程不断循环，用于在一定时间周期内来从 defer 队列中获取要持久化的数据并写入到磁盘的 journal 日志和 mongofile 数据处
- 数据会先写入内存，然后再持久化到硬盘，因此它不会造成性能上的损耗

### Redis

## 其他

### 存储过程

- 存储过程是一些预编译的SQL语句
- 存储过程是一个记录集，是由 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了
- 存储过程是一个预编译的代码块，执行效率比较高，一个存储过程替代大量 T_SQL 语句，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全
