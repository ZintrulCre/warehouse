---
title: "面向对象"
date: 2015-07-05T08:57:52+10:00
draft: true
categories: ["Computer Science"]
---

# 面向对象

## 面向对象思想

### 三大特性

1. 封装
    - 利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象
    - 优点：
        - 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
        - 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
        - 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
        - 提高软件的可重用性
        - 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的

2. 继承
    - 继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法
    - 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象
    - Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型

3. 多态
    - 多态分为编译时多态和运行时多态：
        - 编译时多态主要指方法的重载
        - 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定
    - 运行时多态有三个条件：
        - 继承
        - 覆盖（重写）
        - 向上转型

### 设计原则

1. 单一责任原则
    - 修改一个类的原因应该只有一个
    - 让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类
    - 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力

2. 开放封闭原则
    - 类应该对扩展开放，对修改关闭
    - 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码
    - 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码

3. 里氏替换原则
    - 子类对象必须能够替换掉所有父类对象
    - 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊
    - 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度

4. 接口分离原则
    - 不应该强迫客户依赖于它们不用的方法
    - 因此使用多个专门的接口比使用单一的总接口要好

5. 依赖倒置原则
    - 高层模块不应该依赖于低层模块，二者都应该依赖于抽象
    - 抽象不应该依赖于细节，细节应该依赖于抽象
    - 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
    - 依赖于抽象意味着：
        - 任何变量都不应该持有一个指向具体类的指针或者引用
        - 任何类都不应该从具体类派生
        - 任何方法都不应该覆写它的任何基类中的已经实现的方法

## 设计模式

### 创建型

#### 单例模式 Singleton

- 目的：保证一个类只有一个实例，并提供该实例的全局访问
- 特点
  - 私有构造函数用于保证不能通过构造函数来创建新的对象实例
  - 公有静态函数用于返回唯一的私有静态变量
  - 私有静态变量

#### 简单工厂 Simple Factory

- 目的：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口
- 特点
  - 把实例化的操作单独放到一个简单工厂类中，让简单工厂类来决定应该用哪个具体子类来实例化
  - 把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类
  - 客户类有多个，增加子类时，客户类不需要进行修改

#### 工厂方法 Factory Method

- 目的：定义一个创建对象的接口，由子类决定要实例化哪个类
- 特点
  - 把实例化操作推迟到子类
  - 在简单工厂中，由简单工厂类创建对象；在工厂方法中，由子类创建对象

#### 抽象工厂 Abstract Factory

- 目的：提供一个接口，用于创建相关的对象家族
- 特点
  - 抽象工厂创建的是对象家族，也就是很多对象
  - 这些对象是相关的，也就是说必须一起创建
  - 工厂方法模式只用于创建单个对象
  - 抽象工厂用到了工厂方法来创建单一对象
  - Client 通过 AbstractFactory 同时调用两个方法来创建出两个对象（对象家族），这两个对象有很大的相关性，Client 需要同时创建出这两个对象
  - 抽象工厂使用了组合，Cilent 组合了 AbstractFactory，而工厂方法只使用了继承

#### 生成器 Builder

- 目的：封装一个对象的构造过程，并允许按步骤构造

#### 原型 Prototype

- 目的：使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象

### 行为型

#### 责任链 Chain of Responsibility

- 目的：使多个对象都有机会处理请求，使请求的发送者和接收者解耦
- 特点
  - 将对象连成一条链，沿着链发送请求，直到有一个对象处理为止

#### 命令 Command

- 目的：将命令封装成对象
- 特点
  - 使用命令来参数化其它对象
  - 将命令放入队列中进行排队
  - 将命令的操作记录到日志中
  - 支持可撤销的操作

#### 解释器 Interpreter

- 目的：为语言创建解释器
- 特点
  - 通常由语言的语法和语法分析来定义

#### 迭代器 Iterator

- 目的：提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示
- 特点

#### 中介者 Mediator

- 目的：集中相关对象之间复杂的沟通和控制方式

#### 备忘录 Memento

- 目的：在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态

#### 观察者 Observer

- 目的：定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态

#### 状态 State

- 目的：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类

#### 策略 Strategy

- 目的：定义一系列算法，封装每个算法，并使它们可以互换
- 特点
  - 让算法独立于使用它的客户端

#### 模板方法 Template Method

- 目的：定义算法框架，并将一些步骤的实现延迟到子类
- 特点
  - 通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构

#### 访问者 Visitor

- 目的：为一个对象结构（比如组合结构）增加新能力

#### 空对象 Null

- 目的：用什么都不做的空对象来代替 NULL
- 特点
  - 一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码
  - 如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，有可能抛出空指针异常

### 结构型

#### 适配器 Adapter

- 目的：把一个类接口转换成另一个用户需要的接口

#### 桥接 Bridge

- 目的：将抽象与实现分离开来，使它们可以独立变化

#### 组合 Composite

- 目的：将对象组合成树形结构来表示整体/部分的层次关系，允许用户以相同的方式处理单独对象和组合对象
- 特点
  - 组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象

#### 装饰 Decorator

- 目的：为对象动态添加功能

#### 外观 Facade

- 目的：提供一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用

#### 享元 Flyweight

- 目的：利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的

#### 代理 Proxy

- 目的：控制对其它对象的访问
